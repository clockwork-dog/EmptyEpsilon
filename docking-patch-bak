From 55e799261ce2e51be489d60d0335ce3b9f5b1843 Mon Sep 17 00:00:00 2001
From: Daid <daid303@gmail.com>
Date: Mon, 7 Feb 2022 23:06:08 +0100
Subject: Add option for internal docking bays.

---
 scripts/shiptemplates/corvette.lua     |  3 +-
 src/ai/ai.cpp                          |  2 +-
 src/screenComponents/dockingButton.cpp |  2 +-
 src/screens/gm/gameMasterScreen.cpp    |  2 +-
 src/shipTemplate.cpp                   | 22 ++++++++++++--
 src/shipTemplate.h                     |  5 ++-
 src/spaceObjects/cpuShip.cpp           |  2 ++
 src/spaceObjects/playerSpaceship.cpp   |  2 ++
 src/spaceObjects/spaceObject.h         |  9 +++++-
 src/spaceObjects/spaceStation.cpp      |  8 ++---
 src/spaceObjects/spaceStation.h        |  2 +-
 src/spaceObjects/spaceship.cpp         | 42 ++++++++++++++++++++++----
 src/spaceObjects/spaceship.h           |  5 ++-
 13 files changed, 86 insertions(+), 20 deletions(-)

diff --git a/scripts/shiptemplates/corvette.lua b/scripts/shiptemplates/corvette.lua
index e24aa210..906bf4a4 100644
--- a/scripts/shiptemplates/corvette.lua
+++ b/scripts/shiptemplates/corvette.lua
@@ -307,7 +307,8 @@ template:setSpeed(50, 6, 10)
 template:setRadarTrace("transport.png")
 template:setJumpDrive(true)
 template:setJumpDriveRange(5000, 100 * 50000) -- The jump carrier can jump a 100x longer distance then normal jump drives.
-template:setDockClasses(_("class", "Starfighter"), _("class", "Frigate"), _("class", "Corvette"))
+template:setExternalDockClasses(_("class", "Frigate"), _("class", "Corvette"))
+template:setInternalDockClasses(_("class", "Starfighter"))
 template:setDefaultAI("evasion")
 
 
diff --git a/src/ai/ai.cpp b/src/ai/ai.cpp
index d63680be..37a9fbef 100644
--- a/src/ai/ai.cpp
+++ b/src/ai/ai.cpp
@@ -829,7 +829,7 @@ P<SpaceObject> ShipAI::findBestMissileRestockTarget(glm::vec2 position, float ra
         P<SpaceObject> space_object = obj;
         if (!space_object || !owner->isFriendly(space_object) || space_object == target)
             continue;
-        if (!space_object->canBeDockedBy(owner) || !space_object->canRestockMissiles())
+        if (space_object->canBeDockedBy(owner) == DockStyle::None || !space_object->canRestockMissiles())
             continue;
         //calculate score
         auto position_difference = space_object->getPosition() - owner_position;
diff --git a/src/screenComponents/dockingButton.cpp b/src/screenComponents/dockingButton.cpp
index 66173fb4..db2e224c 100644
--- a/src/screenComponents/dockingButton.cpp
+++ b/src/screenComponents/dockingButton.cpp
@@ -92,7 +92,7 @@ P<SpaceObject> GuiDockingButton::findDockingTarget()
     foreach(Collisionable, obj, obj_list)
     {
         dock_object = obj;
-        if (dock_object && dock_object != my_spaceship && dock_object->canBeDockedBy(my_spaceship) && glm::length(dock_object->getPosition() - my_spaceship->getPosition()) < 1000.0f + dock_object->getRadius())
+        if (dock_object && dock_object != my_spaceship && dock_object->canBeDockedBy(my_spaceship) != DockStyle::None && glm::length(dock_object->getPosition() - my_spaceship->getPosition()) < 1000.0f + dock_object->getRadius())
             break;
         dock_object = NULL;
     }
diff --git a/src/screens/gm/gameMasterScreen.cpp b/src/screens/gm/gameMasterScreen.cpp
index b801fdc1..4c13e719 100644
--- a/src/screens/gm/gameMasterScreen.cpp
+++ b/src/screens/gm/gameMasterScreen.cpp
@@ -515,7 +515,7 @@ void GameMasterScreen::onMouseUp(glm::vec2 position)
                         {
                             cpu_ship->orderAttack(target);
                         }else{
-                            if (!shift_down && target->canBeDockedBy(cpu_ship))
+                            if (!shift_down && target->canBeDockedBy(cpu_ship) != DockStyle::None)
                                 cpu_ship->orderDock(target);
                             else
                                 cpu_ship->orderDefendTarget(target);
diff --git a/src/shipTemplate.cpp b/src/shipTemplate.cpp
index 0bd4d78b..f8e582c2 100644
--- a/src/shipTemplate.cpp
+++ b/src/shipTemplate.cpp
@@ -28,7 +28,14 @@ REGISTER_SCRIPT_CLASS(ShipTemplate)
     /// Set the 3D model to be used for this template. The model referers to data set in the model_data.lua file.
     REGISTER_SCRIPT_CLASS_FUNCTION(ShipTemplate, setModel);
     /// Supply a list of ship classes that can be docked to this ship. setDockClasses("Starfighter") will allow all small starfighter type ships to dock with this ship.
+    /// (Same as setExternalDockClasses)
     REGISTER_SCRIPT_CLASS_FUNCTION(ShipTemplate, setDockClasses);
+    /// Supply a list of ship classes that can be docked to this ship. setExternalDockClasses("Starfighter") will allow all small starfighter type ships to dock with this ship.
+    /// External docking will keep the ship attached to the side of this ship.
+    REGISTER_SCRIPT_CLASS_FUNCTION(ShipTemplate, setExternalDockClasses);
+    /// Supply a list of ship classes that can be docked to this ship. setInternalDockClasses("Starfighter") will allow all small starfighter type ships to dock with this ship.
+    /// Internal docking will hide the docked ship inside the other ship.
+    REGISTER_SCRIPT_CLASS_FUNCTION(ShipTemplate, setInternalDockClasses);
     /// Set the amount of energy available for this ship. Note that only player ships use energy. So setting this for anything else is useless.
     REGISTER_SCRIPT_CLASS_FUNCTION(ShipTemplate, setEnergyStorage);
     REGISTER_SCRIPT_CLASS_FUNCTION(ShipTemplate, setRepairCrewCount);
@@ -417,7 +424,17 @@ void ShipTemplate::setDefaultAI(string default_ai_name)
 
 void ShipTemplate::setDockClasses(const std::vector<string>& classes)
 {
-    can_be_docked_by_class = std::unordered_set<string>(classes.begin(), classes.end());
+    external_dock_classes = std::unordered_set<string>(classes.begin(), classes.end());
+}
+
+void ShipTemplate::setExternalDockClasses(const std::vector<string>& classes)
+{
+    external_dock_classes = std::unordered_set<string>(classes.begin(), classes.end());
+}
+
+void ShipTemplate::setInternalDockClasses(const std::vector<string>& classes)
+{
+    internal_dock_classes = std::unordered_set<string>(classes.begin(), classes.end());
 }
 
 void ShipTemplate::setSpeed(float impulse, float turn, float acceleration, std::optional<float> reverse_speed, std::optional<float> reverse_acceleration)
@@ -529,7 +546,8 @@ P<ShipTemplate> ShipTemplate::copy(string new_name)
     result->type = type;
     result->model_data = model_data;
 
-    result->can_be_docked_by_class = can_be_docked_by_class;
+    result->external_dock_classes = external_dock_classes;
+    result->internal_dock_classes = internal_dock_classes;
     result->energy_storage_amount = energy_storage_amount;
     result->repair_crew_count = repair_crew_count;
 
diff --git a/src/shipTemplate.h b/src/shipTemplate.h
index 24256812..9906379e 100644
--- a/src/shipTemplate.h
+++ b/src/shipTemplate.h
@@ -92,7 +92,8 @@ public:
     /*!
      * List of ship classes that can dock with this ship. (only used for ship2ship docking)
      */
-    std::unordered_set<string> can_be_docked_by_class;
+    std::unordered_set<string> external_dock_classes;
+    std::unordered_set<string> internal_dock_classes;
     bool shares_energy_with_docked;
     bool repair_docked;
     bool restocks_scan_probes;
@@ -140,6 +141,8 @@ public:
     void setModel(string model_name);
     void setDefaultAI(string default_ai_name);
     void setDockClasses(const std::vector<string>& classes);
+    void setExternalDockClasses(const std::vector<string>& classes);
+    void setInternalDockClasses(const std::vector<string>& classes);
     void setSharesEnergyWithDocked(bool enabled);
     void setRepairDocked(bool enabled);
     void setRestocksScanProbes(bool enabled);
diff --git a/src/spaceObjects/cpuShip.cpp b/src/spaceObjects/cpuShip.cpp
index 2e40acac..c272cb09 100644
--- a/src/spaceObjects/cpuShip.cpp
+++ b/src/spaceObjects/cpuShip.cpp
@@ -297,6 +297,8 @@ void CpuShip::orderDock(P<SpaceObject> object)
 
 void CpuShip::drawOnGMRadar(sp::RenderTarget& renderer, glm::vec2 position, float scale, float rotation, bool long_range)
 {
+    if (docked_style == DockStyle::Internal) return;
+
     SpaceShip::drawOnGMRadar(renderer, position, scale, rotation, long_range);
     if (game_server && ai)
         ai->drawOnGMRadar(renderer, position, scale);
diff --git a/src/spaceObjects/playerSpaceship.cpp b/src/spaceObjects/playerSpaceship.cpp
index cc935497..05ddea79 100644
--- a/src/spaceObjects/playerSpaceship.cpp
+++ b/src/spaceObjects/playerSpaceship.cpp
@@ -2015,6 +2015,8 @@ void PlayerSpaceship::onReceiveServerCommand(sp::io::DataBuffer& packet)
 
 void PlayerSpaceship::drawOnGMRadar(sp::RenderTarget& renderer, glm::vec2 position, float scale, float rotation, bool long_range)
 {
+    if (docked_style == DockStyle::Internal) return;
+
     SpaceShip::drawOnGMRadar(renderer, position, scale, rotation, long_range);
 
     if (long_range)
diff --git a/src/spaceObjects/spaceObject.h b/src/spaceObjects/spaceObject.h
index 1475926b..bf4c0cc9 100644
--- a/src/spaceObjects/spaceObject.h
+++ b/src/spaceObjects/spaceObject.h
@@ -19,6 +19,13 @@ enum EDamageType
     DT_EMP
 };
 
+enum class DockStyle
+{
+    None,
+    External,
+    Internal,
+};
+
 class DamageInfo
 {
 public:
@@ -193,7 +200,7 @@ public:
 
     virtual void setCallSign(string new_callsign) { callsign = new_callsign; }
     virtual string getCallSign() { return callsign; }
-    virtual bool canBeDockedBy(P<SpaceObject> obj) { return false; }
+    virtual DockStyle canBeDockedBy(P<SpaceObject> obj) { return DockStyle::None; }
     virtual bool canRestockMissiles() { return false; }
     virtual bool hasShield() { return false; }
     virtual bool canHideInNebula() { return true; }
diff --git a/src/spaceObjects/spaceStation.cpp b/src/spaceObjects/spaceStation.cpp
index 912ebe3e..6c68a2ba 100644
--- a/src/spaceObjects/spaceStation.cpp
+++ b/src/spaceObjects/spaceStation.cpp
@@ -80,14 +80,14 @@ void SpaceStation::destroyedByDamage(DamageInfo& info)
     }
 }
 
-bool SpaceStation::canBeDockedBy(P<SpaceObject> obj)
+DockStyle SpaceStation::canBeDockedBy(P<SpaceObject> obj)
 {
     if (isEnemy(obj))
-        return false;
+        return DockStyle::None;
     P<SpaceShip> ship = obj;
     if (!ship)
-        return false;
-    return true;
+        return DockStyle::None;
+    return DockStyle::External;
 }
 
 string SpaceStation::getExportLine()
diff --git a/src/spaceObjects/spaceStation.h b/src/spaceObjects/spaceStation.h
index 3f37feed..d9c6078d 100644
--- a/src/spaceObjects/spaceStation.h
+++ b/src/spaceObjects/spaceStation.h
@@ -9,7 +9,7 @@ public:
     SpaceStation();
 
     virtual void drawOnRadar(sp::RenderTarget& renderer, glm::vec2 position, float scale, float rotation, bool long_range) override;
-    virtual bool canBeDockedBy(P<SpaceObject> obj) override;
+    virtual DockStyle canBeDockedBy(P<SpaceObject> obj) override;
     virtual void destroyedByDamage(DamageInfo& info) override;
     virtual void applyTemplateValues() override;
 
diff --git a/src/spaceObjects/spaceship.cpp b/src/spaceObjects/spaceship.cpp
index cb47ce2b..f78fb719 100644
--- a/src/spaceObjects/spaceship.cpp
+++ b/src/spaceObjects/spaceship.cpp
@@ -237,6 +237,7 @@ SpaceShip::SpaceShip(string multiplayerClassName, float multiplayer_significant_
     registerMemberReplication(&warp_speed_per_warp_level);
     registerMemberReplication(&shield_frequency);
     registerMemberReplication(&docking_state);
+    registerMemberReplication(&docked_style);
     registerMemberReplication(&beam_frequency);
     registerMemberReplication(&combat_maneuver_charge, 0.5f);
     registerMemberReplication(&combat_maneuver_boost_request);
@@ -357,9 +358,16 @@ void SpaceShip::applyTemplateValues()
     model_info.setData(ship_template->model_data);
 }
 
+void SpaceShip::draw3D()
+{
+    if (docked_style == DockStyle::Internal) return;
+    ShipTemplateBasedObject::draw3D();
+}
+
 void SpaceShip::draw3DTransparent()
 {
     if (!ship_template) return;
+    if (docked_style == DockStyle::Internal) return;
     ShipTemplateBasedObject::draw3DTransparent();
 
     if ((has_jump_drive && jump_delay > 0.0f) ||
@@ -445,6 +453,8 @@ RawRadarSignatureInfo SpaceShip::getDynamicRadarSignatureInfo()
 
 void SpaceShip::drawOnRadar(sp::RenderTarget& renderer, glm::vec2 position, float scale, float rotation, bool long_range)
 {
+    if (docked_style == DockStyle::Internal) return;
+
     // Draw beam arcs on short-range radar only, and only for fully scanned
     // ships.
     if (!long_range && (!my_spaceship || (getScannedStateFor(my_spaceship) == SS_FullScan)))
@@ -639,6 +649,8 @@ void SpaceShip::drawOnRadar(sp::RenderTarget& renderer, glm::vec2 position, floa
 
 void SpaceShip::drawOnGMRadar(sp::RenderTarget& renderer, glm::vec2 position, float scale, float rotation, bool long_range)
 {
+    if (docked_style == DockStyle::Internal) return;
+
     if (!long_range)
     {
         renderer.fillRect(sp::Rect(position.x - 30, position.y - 30, 60 * hull_strength / hull_max, 5), glm::u8vec4(128, 255, 128, 128));
@@ -649,6 +661,14 @@ void SpaceShip::update(float delta)
 {
     ShipTemplateBasedObject::update(delta);
 
+    if (hasCollisionShape() != (docked_style != DockStyle::Internal))
+    {
+        if (docked_style == DockStyle::Internal)
+            setCollisionRadius(0);
+        else if (ship_template)
+            ship_template->setCollisionData(this);
+    }
+
     if (game_server)
     {
         if (docking_state == DS_Docking)
@@ -667,6 +687,7 @@ void SpaceShip::update(float delta)
             if (!docking_target)
             {
                 docking_state = DS_NotDocking;
+                docked_style = DockStyle::None;
             }else{
                 setPosition(docking_target->getPosition() + rotateVec2(docking_offset, docking_target->getRotation()));
                 target_rotation = vec2ToAngle(getPosition() - docking_target->getPosition());
@@ -936,15 +957,22 @@ void SpaceShip::executeJump(float distance)
     addHeat(SYS_JumpDrive, jump_drive_heat_per_jump);
 }
 
-bool SpaceShip::canBeDockedBy(P<SpaceObject> obj)
+DockStyle SpaceShip::canBeDockedBy(P<SpaceObject> obj)
 {
     if (isEnemy(obj) || !ship_template)
-        return false;
+        return DockStyle::None;
     P<SpaceShip> ship = obj;
     if (!ship || !ship->ship_template)
-        return false;
-    return (ship_template->can_be_docked_by_class.count(ship->ship_template->getClass()) +
-       ship_template->can_be_docked_by_class.count(ship->ship_template->getSubClass())) > 0;
+        return DockStyle::None;
+    if (ship_template->external_dock_classes.count(ship->ship_template->getClass()) > 0)
+        return DockStyle::External;
+    if (ship_template->external_dock_classes.count(ship->ship_template->getSubClass()) > 0)
+        return DockStyle::External;
+    if (ship_template->internal_dock_classes.count(ship->ship_template->getClass()) > 0)
+        return DockStyle::Internal;
+    if (ship_template->internal_dock_classes.count(ship->ship_template->getSubClass()) > 0)
+        return DockStyle::Internal;
+    return DockStyle::None;
 }
 
 void SpaceShip::collide(Collisionable* other, float force)
@@ -955,6 +983,7 @@ void SpaceShip::collide(Collisionable* other, float force)
         if (dock_object == docking_target)
         {
             docking_state = DS_Docked;
+            docked_style = docking_target->canBeDockedBy(this);
             docking_offset = rotateVec2(getPosition() - other->getPosition(), -other->getRotation());
             float length = glm::length(docking_offset);
             docking_offset = docking_offset / length * (length + 2.0f);
@@ -978,7 +1007,7 @@ void SpaceShip::initializeJump(float distance)
 
 void SpaceShip::requestDock(P<SpaceObject> target)
 {
-    if (!target || docking_state != DS_NotDocking || !target->canBeDockedBy(this))
+    if (!target || docking_state != DS_NotDocking || target->canBeDockedBy(this) == DockStyle::None)
         return;
     if (glm::length(getPosition() - target->getPosition()) > 1000 + target->getRadius())
         return;
@@ -994,6 +1023,7 @@ void SpaceShip::requestUndock()
 {
     if (docking_state == DS_Docked && getSystemEffectiveness(SYS_Impulse) > 0.1f)
     {
+        docked_style = DockStyle::None;
         docking_state = DS_NotDocking;
         impulse_request = 0.5;
     }
diff --git a/src/spaceObjects/spaceship.h b/src/spaceObjects/spaceship.h
index 33ce952e..78a32031 100644
--- a/src/spaceObjects/spaceship.h
+++ b/src/spaceObjects/spaceship.h
@@ -208,12 +208,14 @@ public:
     int32_t target_id;
 
     EDockingState docking_state;
+    DockStyle docked_style;
     P<SpaceObject> docking_target; //Server only
     glm::vec2 docking_offset{0, 0}; //Server only
 
     SpaceShip(string multiplayerClassName, float multiplayer_significant_range=-1);
     virtual ~SpaceShip();
 
+    virtual void draw3D() override;
     virtual void draw3DTransparent() override;
     /*!
      * Get this ship's radar signature dynamically modified by the state of its
@@ -270,7 +272,7 @@ public:
      * Check if object can dock with this ship.
      * \param object Object that wants to dock.
      */
-    virtual bool canBeDockedBy(P<SpaceObject> obj) override;
+    virtual DockStyle canBeDockedBy(P<SpaceObject> obj) override;
 
     virtual void collide(Collisionable* other, float force) override;
 
@@ -516,6 +518,7 @@ REGISTER_MULTIPLAYER_ENUM(EWeaponTubeState);
 REGISTER_MULTIPLAYER_ENUM(EMainScreenSetting);
 REGISTER_MULTIPLAYER_ENUM(EMainScreenOverlay);
 REGISTER_MULTIPLAYER_ENUM(EDockingState);
+REGISTER_MULTIPLAYER_ENUM(DockStyle);
 REGISTER_MULTIPLAYER_ENUM(EScannedState);
 
 string frequencyToString(int frequency);
-- 
2.43.0

